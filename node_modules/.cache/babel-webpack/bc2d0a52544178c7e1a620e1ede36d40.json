{"ast":null,"code":"import _slicedToArray from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createClass from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngrx/store';\n\nvar StoreDevtoolsConfig = /*#__PURE__*/_createClass(function StoreDevtoolsConfig() {\n  _classCallCheck(this, StoreDevtoolsConfig);\n\n  this.maxAge = false;\n});\n\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\n\nfunction noMonitor() {\n  return null;\n}\n\nvar DEFAULT_NAME = 'NgRx Store DevTools';\n\nfunction createConfig(_options) {\n  var DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      lock: true,\n      persist: true,\n      export: true,\n      import: 'custom',\n      jump: true,\n      skip: true,\n      reorder: true,\n      dispatch: true,\n      test: true\n    }\n  };\n  var options = typeof _options === 'function' ? _options() : _options;\n  var logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  var features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  var config = Object.assign({}, DEFAULT_OPTIONS, {\n    features: features\n  }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \".concat(config.maxAge));\n  }\n\n  return config;\n}\n\nvar PERFORM_ACTION = 'PERFORM_ACTION';\nvar REFRESH = 'REFRESH';\nvar RESET = 'RESET';\nvar ROLLBACK = 'ROLLBACK';\nvar COMMIT = 'COMMIT';\nvar SWEEP = 'SWEEP';\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\nvar JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nvar IMPORT_STATE = 'IMPORT_STATE';\nvar LOCK_CHANGES = 'LOCK_CHANGES';\nvar PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nvar PerformAction = /*#__PURE__*/_createClass(function PerformAction(action, timestamp) {\n  _classCallCheck(this, PerformAction);\n\n  this.action = action;\n  this.timestamp = timestamp;\n  this.type = PERFORM_ACTION;\n\n  if (typeof action.type === 'undefined') {\n    throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n  }\n});\n\nvar Refresh = /*#__PURE__*/_createClass(function Refresh() {\n  _classCallCheck(this, Refresh);\n\n  this.type = REFRESH;\n});\n\nvar Reset = /*#__PURE__*/_createClass(function Reset(timestamp) {\n  _classCallCheck(this, Reset);\n\n  this.timestamp = timestamp;\n  this.type = RESET;\n});\n\nvar Rollback = /*#__PURE__*/_createClass(function Rollback(timestamp) {\n  _classCallCheck(this, Rollback);\n\n  this.timestamp = timestamp;\n  this.type = ROLLBACK;\n});\n\nvar Commit = /*#__PURE__*/_createClass(function Commit(timestamp) {\n  _classCallCheck(this, Commit);\n\n  this.timestamp = timestamp;\n  this.type = COMMIT;\n});\n\nvar Sweep = /*#__PURE__*/_createClass(function Sweep() {\n  _classCallCheck(this, Sweep);\n\n  this.type = SWEEP;\n});\n\nvar ToggleAction = /*#__PURE__*/_createClass(function ToggleAction(id) {\n  _classCallCheck(this, ToggleAction);\n\n  this.id = id;\n  this.type = TOGGLE_ACTION;\n});\n\nvar SetActionsActive = /*#__PURE__*/_createClass(function SetActionsActive(start, end) {\n  var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  _classCallCheck(this, SetActionsActive);\n\n  this.start = start;\n  this.end = end;\n  this.active = active;\n  this.type = SET_ACTIONS_ACTIVE;\n});\n\nvar JumpToState = /*#__PURE__*/_createClass(function JumpToState(index) {\n  _classCallCheck(this, JumpToState);\n\n  this.index = index;\n  this.type = JUMP_TO_STATE;\n});\n\nvar JumpToAction = /*#__PURE__*/_createClass(function JumpToAction(actionId) {\n  _classCallCheck(this, JumpToAction);\n\n  this.actionId = actionId;\n  this.type = JUMP_TO_ACTION;\n});\n\nvar ImportState = /*#__PURE__*/_createClass(function ImportState(nextLiftedState) {\n  _classCallCheck(this, ImportState);\n\n  this.nextLiftedState = nextLiftedState;\n  this.type = IMPORT_STATE;\n});\n\nvar LockChanges = /*#__PURE__*/_createClass(function LockChanges(status) {\n  _classCallCheck(this, LockChanges);\n\n  this.status = status;\n  this.type = LOCK_CHANGES;\n});\n\nvar PauseRecording = /*#__PURE__*/_createClass(function PauseRecording(status) {\n  _classCallCheck(this, PauseRecording);\n\n  this.status = status;\n  this.type = PAUSE_RECORDING;\n});\n\nvar DevtoolsDispatcher = /*#__PURE__*/function (_ActionsSubject) {\n  _inherits(DevtoolsDispatcher, _ActionsSubject);\n\n  var _super = _createSuper(DevtoolsDispatcher);\n\n  function DevtoolsDispatcher() {\n    _classCallCheck(this, DevtoolsDispatcher);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(DevtoolsDispatcher);\n}(ActionsSubject);\n\nDevtoolsDispatcher.ɵfac = function DevtoolsDispatcher_Factory(t) {\n  return ɵDevtoolsDispatcher_BaseFactory(t || DevtoolsDispatcher);\n};\n\nDevtoolsDispatcher.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DevtoolsDispatcher,\n  factory: DevtoolsDispatcher.ɵfac\n});\nvar ɵDevtoolsDispatcher_BaseFactory = /*@__PURE__*/ɵngcc0.ɵɵgetInheritedFactory(DevtoolsDispatcher);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DevtoolsDispatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nfunction difference(first, second) {\n  return first.filter(function (item) {\n    return second.indexOf(item) < 0;\n  });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex; // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n\n  if (currentStateIndex >= computedStates.length) {\n    var _state = computedStates[computedStates.length - 1].state;\n    return _state;\n  }\n\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\n\n\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce(function (sanitizedActions, actionIdx) {\n    var idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\n\n\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign(Object.assign({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n */\n\n\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map(function (computedState, idx) {\n    return {\n      state: sanitizeState(stateSanitizer, computedState.state, idx),\n      error: computedState.error\n    };\n  });\n}\n/**\n * Sanitizes given state with given function.\n */\n\n\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\n\n\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\n\n\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  var filteredStagedActionIds = [];\n  var filteredActionsById = {};\n  var filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach(function (id, idx) {\n    var liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign(Object.assign({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n */\n\n\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  var predicateMatch = predicate && !predicate(state, action.action);\n  var safelistMatch = safelist && !action.action.type.match(safelist.map(function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  var blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nvar ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\n\nvar DevtoolsExtension = /*#__PURE__*/function () {\n  function DevtoolsExtension(devtoolsExtension, config, dispatcher) {\n    _classCallCheck(this, DevtoolsExtension);\n\n    this.config = config;\n    this.dispatcher = dispatcher;\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n\n  _createClass(DevtoolsExtension, [{\n    key: \"notify\",\n    value: function notify(action, state) {\n      var _this = this;\n\n      if (!this.devtoolsExtension) {\n        return;\n      } // Check to see if the action requires a full update of the liftedState.\n      // If it is a simple action generated by the user's app and the recording\n      // is not locked/paused, only send the action and the current state (fast).\n      //\n      // A full liftedState update (slow: serializes the entire liftedState) is\n      // only required when:\n      //   a) redux-devtools-extension fires the @@Init action (ignored by\n      //      @ngrx/store-devtools)\n      //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n      //      or @ngrx/store/update-reducers)\n      //   c) the state has been recomputed due to time-traveling\n      //   d) any action that is not a PerformAction to err on the side of\n      //      caution.\n\n\n      if (action.type === PERFORM_ACTION) {\n        if (state.isLocked || state.isPaused) {\n          return;\n        }\n\n        var currentState = unliftState(state);\n\n        if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n          return;\n        }\n\n        var sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n        var sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n        this.sendToReduxDevtools(function () {\n          return _this.extensionConnection.send(sanitizedAction, sanitizedState);\n        });\n      } else {\n        // Requires full state update\n        var sanitizedLiftedState = Object.assign(Object.assign({}, state), {\n          stagedActionIds: state.stagedActionIds,\n          actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n          computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n        });\n        this.sendToReduxDevtools(function () {\n          return _this.devtoolsExtension.send(null, sanitizedLiftedState, _this.getExtensionConfig(_this.config));\n        });\n      }\n    }\n  }, {\n    key: \"createChangesObservable\",\n    value: function createChangesObservable() {\n      var _this2 = this;\n\n      if (!this.devtoolsExtension) {\n        return EMPTY;\n      }\n\n      return new Observable(function (subscriber) {\n        var connection = _this2.devtoolsExtension.connect(_this2.getExtensionConfig(_this2.config));\n\n        _this2.extensionConnection = connection;\n        connection.init();\n        connection.subscribe(function (change) {\n          return subscriber.next(change);\n        });\n        return connection.unsubscribe;\n      });\n    }\n  }, {\n    key: \"createActionStreams\",\n    value: function createActionStreams() {\n      var _this3 = this;\n\n      // Listens to all changes\n      var changes$ = this.createChangesObservable().pipe(share()); // Listen for the start action\n\n      var start$ = changes$.pipe(filter(function (change) {\n        return change.type === ExtensionActionTypes.START;\n      })); // Listen for the stop action\n\n      var stop$ = changes$.pipe(filter(function (change) {\n        return change.type === ExtensionActionTypes.STOP;\n      })); // Listen for lifted actions\n\n      var liftedActions$ = changes$.pipe(filter(function (change) {\n        return change.type === ExtensionActionTypes.DISPATCH;\n      }), map(function (change) {\n        return _this3.unwrapAction(change.payload);\n      }), concatMap(function (action) {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return _this3.dispatcher.pipe(filter(function (action) {\n            return action.type === UPDATE;\n          }), timeout(1000), debounceTime(1000), map(function () {\n            return action;\n          }), catchError(function () {\n            return of(action);\n          }), take(1));\n        } else {\n          return of(action);\n        }\n      })); // Listen for unlifted actions\n\n      var actions$ = changes$.pipe(filter(function (change) {\n        return change.type === ExtensionActionTypes.ACTION;\n      }), map(function (change) {\n        return _this3.unwrapAction(change.payload);\n      }));\n      var actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n      var liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n      this.start$ = start$.pipe(takeUntil(stop$)); // Only take the action sources between the start/stop events\n\n      this.actions$ = this.start$.pipe(switchMap(function () {\n        return actionsUntilStop$;\n      }));\n      this.liftedActions$ = this.start$.pipe(switchMap(function () {\n        return liftedUntilStop$;\n      }));\n    }\n  }, {\n    key: \"unwrapAction\",\n    value: function unwrapAction(action) {\n      return typeof action === 'string' ? eval(\"(\".concat(action, \")\")) : action;\n    }\n  }, {\n    key: \"getExtensionConfig\",\n    value: function getExtensionConfig(config) {\n      var extensionOptions = {\n        name: config.name,\n        features: config.features,\n        serialize: config.serialize\n      };\n\n      if (config.maxAge !== false\n      /* support === 0 */\n      ) {\n        extensionOptions.maxAge = config.maxAge;\n      }\n\n      return extensionOptions;\n    }\n  }, {\n    key: \"sendToReduxDevtools\",\n    value: function sendToReduxDevtools(send) {\n      try {\n        send();\n      } catch (err) {\n        console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n      }\n    }\n  }]);\n\n  return DevtoolsExtension;\n}();\n\nDevtoolsExtension.ɵfac = function DevtoolsExtension_Factory(t) {\n  return new (t || DevtoolsExtension)(ɵngcc0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG), ɵngcc0.ɵɵinject(DevtoolsDispatcher));\n};\n\nDevtoolsExtension.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: DevtoolsExtension,\n  factory: DevtoolsExtension.ɵfac\n});\n/** @nocollapse */\n\nDevtoolsExtension.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [REDUX_DEVTOOLS_EXTENSION]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }, {\n    type: DevtoolsDispatcher\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DevtoolsExtension, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [REDUX_DEVTOOLS_EXTENSION]\n      }]\n    }, {\n      type: StoreDevtoolsConfig,\n      decorators: [{\n        type: Inject,\n        args: [STORE_DEVTOOLS_CONFIG]\n      }]\n    }, {\n      type: DevtoolsDispatcher\n    }];\n  }, null);\n})();\n\nvar INIT_ACTION = {\n  type: INIT\n};\nvar RECOMPUTE = '@ngrx/store-devtools/recompute';\nvar RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * Computes the next entry in the log by applying an action.\n */\n\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state: state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n\n  var nextState = state;\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex); // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n\n  var lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n\n  for (var i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var previousError = previousEntry ? previousEntry.error : undefined;\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  } // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n\n\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return function (reducer) {\n    return function (liftedState, liftedAction) {\n      var _ref = liftedState || initialLiftedState,\n          monitorState = _ref.monitorState,\n          actionsById = _ref.actionsById,\n          nextActionId = _ref.nextActionId,\n          stagedActionIds = _ref.stagedActionIds,\n          skippedActionIds = _ref.skippedActionIds,\n          committedState = _ref.committedState,\n          currentStateIndex = _ref.currentStateIndex,\n          computedStates = _ref.computedStates,\n          isLocked = _ref.isLocked,\n          isPaused = _ref.isPaused;\n\n      if (!liftedState) {\n        // Prevent mutating initialLiftedState\n        actionsById = Object.create(actionsById);\n      }\n\n      function commitExcessActions(n) {\n        // Auto-commits n-number of excess actions.\n        var excess = n;\n        var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n        for (var i = 0; i < idsToDelete.length; i++) {\n          if (computedStates[i + 1].error) {\n            // Stop if error is found. Commit actions up to error.\n            excess = i;\n            idsToDelete = stagedActionIds.slice(1, excess + 1);\n            break;\n          } else {\n            delete actionsById[idsToDelete[i]];\n          }\n        }\n\n        skippedActionIds = skippedActionIds.filter(function (id) {\n          return idsToDelete.indexOf(id) === -1;\n        });\n        stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n        committedState = computedStates[excess].state;\n        computedStates = computedStates.slice(excess);\n        currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n      }\n\n      function commitChanges() {\n        // Consider the last committed state the new starting point.\n        // Squash any staged actions into a single committed state.\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // By default, aggressively recompute every state whatever happens.\n      // This has O(n) performance, so we'll override this to a sensible\n      // value whenever we feel like we don't have to recompute the states.\n\n\n      var minInvalidatedStateIndex = 0;\n\n      switch (liftedAction.type) {\n        case LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              // Add a pause action to signal the devtools-user the recording is paused.\n              // The corresponding state will be overwritten on each update to always contain\n              // the latest state (see Actions.PERFORM_ACTION).\n              stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n              actionsById[nextActionId] = new PerformAction({\n                type: '@ngrx/devtools/pause'\n              }, +Date.now());\n              nextActionId++;\n              minInvalidatedStateIndex = stagedActionIds.length - 1;\n              computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n\n              if (currentStateIndex === stagedActionIds.length - 2) {\n                currentStateIndex++;\n              }\n\n              minInvalidatedStateIndex = Infinity;\n            } else {\n              commitChanges();\n            }\n\n            break;\n          }\n\n        case RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case COMMIT:\n          {\n            commitChanges();\n            break;\n          }\n\n        case ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var actionId = liftedAction.id;\n            var index = skippedActionIds.indexOf(actionId);\n\n            if (index === -1) {\n              skippedActionIds = [actionId].concat(_toConsumableArray(skippedActionIds));\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== actionId;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n            break;\n          }\n\n        case SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = difference(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = [].concat(_toConsumableArray(skippedActionIds), actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = difference(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case PERFORM_ACTION:\n          {\n            // Ignore action and return state as is if recording is locked\n            if (isLocked) {\n              return liftedState || initialLiftedState;\n            }\n\n            if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n              // If recording is paused or if the action should be ignored, overwrite the last state\n              // (corresponds to the pause action) and keep everything else as is.\n              // This way, the app gets the new current state while the devtools\n              // do not record another action.\n              var lastState = computedStates[computedStates.length - 1];\n              computedStates = [].concat(_toConsumableArray(computedStates.slice(0, -1)), [computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)]);\n              minInvalidatedStateIndex = Infinity;\n              break;\n            } // Auto-commit as new actions come in.\n\n\n            if (options.maxAge && stagedActionIds.length === options.maxAge) {\n              commitExcessActions(1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var _actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n\n            actionsById[_actionId] = liftedAction;\n            stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case IMPORT_STATE:\n          {\n            // Completely replace everything.\n            var _liftedAction$nextLif = liftedAction.nextLiftedState;\n            monitorState = _liftedAction$nextLif.monitorState;\n            actionsById = _liftedAction$nextLif.actionsById;\n            nextActionId = _liftedAction$nextLif.nextActionId;\n            stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n            skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n            committedState = _liftedAction$nextLif.committedState;\n            currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n            computedStates = _liftedAction$nextLif.computedStates;\n            isLocked = _liftedAction$nextLif.isLocked;\n            isPaused = _liftedAction$nextLif.isPaused;\n            break;\n          }\n\n        case INIT:\n          {\n            // Always recompute states on hot reload and init.\n            minInvalidatedStateIndex = 0;\n\n            if (options.maxAge && stagedActionIds.length > options.maxAge) {\n              // States must be recomputed before committing excess.\n              computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        case UPDATE:\n          {\n            var stateHasErrors = computedStates.filter(function (state) {\n              return state.error;\n            }).length > 0;\n\n            if (stateHasErrors) {\n              // Recompute all states\n              minInvalidatedStateIndex = 0;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                // States must be recomputed before committing excess.\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n                minInvalidatedStateIndex = Infinity;\n              }\n            } else {\n              // If not paused/locked, add a new action to signal devtools-user\n              // that there was a reducer update.\n              if (!isPaused && !isLocked) {\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                  currentStateIndex++;\n                } // Add a new action to only recompute state\n\n\n                var _actionId2 = nextActionId++;\n\n                actionsById[_actionId2] = new PerformAction(liftedAction, +Date.now());\n                stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]);\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n              } // Recompute state history with latest reducer and update action\n\n\n              computedStates = computedStates.map(function (cmp) {\n                return Object.assign(Object.assign({}, cmp), {\n                  state: reducer(cmp.state, RECOMPUTE_ACTION)\n                });\n              });\n              currentStateIndex = stagedActionIds.length - 1;\n\n              if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                commitExcessActions(stagedActionIds.length - options.maxAge);\n              } // Avoid double computation.\n\n\n              minInvalidatedStateIndex = Infinity;\n            }\n\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n\n      computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n      monitorState = monitorReducer(monitorState, liftedAction);\n      return {\n        monitorState: monitorState,\n        actionsById: actionsById,\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: computedStates,\n        isLocked: isLocked,\n        isPaused: isPaused\n      };\n    };\n  };\n}\n\nvar StoreDevtools = /*#__PURE__*/function () {\n  function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n    var _this4 = this;\n\n    _classCallCheck(this, StoreDevtools);\n\n    var liftedInitialState = liftInitialState(initialState, config.monitor);\n    var liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n    var liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n    var liftedReducer$ = reducers$.pipe(map(liftReducer));\n    var liftedStateSubject = new ReplaySubject(1);\n    var liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(function (_ref2, _ref3) {\n      var liftedState = _ref2.state;\n\n      var _ref4 = _slicedToArray(_ref3, 2),\n          action = _ref4[0],\n          reducer = _ref4[1];\n\n      var reducedLiftedState = reducer(liftedState, action); // On full state update\n      // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n\n      if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n        reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n      } // Extension should be sent the sanitized lifted state\n\n\n      extension.notify(action, reducedLiftedState);\n      return {\n        state: reducedLiftedState,\n        action: action\n      };\n    }, {\n      state: liftedInitialState,\n      action: null\n    })).subscribe(function (_ref5) {\n      var state = _ref5.state,\n          action = _ref5.action;\n      liftedStateSubject.next(state);\n\n      if (action.type === PERFORM_ACTION) {\n        var unliftedAction = action.action;\n        scannedActions.next(unliftedAction);\n      }\n    });\n    var extensionStartSubscription = extension.start$.subscribe(function () {\n      _this4.refresh();\n    });\n    var liftedState$ = liftedStateSubject.asObservable();\n    var state$ = liftedState$.pipe(map(unliftState));\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n\n  _createClass(StoreDevtools, [{\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      this.dispatcher.next(action);\n    }\n  }, {\n    key: \"next\",\n    value: function next(action) {\n      this.dispatcher.next(action);\n    }\n  }, {\n    key: \"error\",\n    value: function error(_error) {}\n  }, {\n    key: \"complete\",\n    value: function complete() {}\n  }, {\n    key: \"performAction\",\n    value: function performAction(action) {\n      this.dispatch(new PerformAction(action, +Date.now()));\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.dispatch(new Refresh());\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.dispatch(new Reset(+Date.now()));\n    }\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      this.dispatch(new Rollback(+Date.now()));\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      this.dispatch(new Commit(+Date.now()));\n    }\n  }, {\n    key: \"sweep\",\n    value: function sweep() {\n      this.dispatch(new Sweep());\n    }\n  }, {\n    key: \"toggleAction\",\n    value: function toggleAction(id) {\n      this.dispatch(new ToggleAction(id));\n    }\n  }, {\n    key: \"jumpToAction\",\n    value: function jumpToAction(actionId) {\n      this.dispatch(new JumpToAction(actionId));\n    }\n  }, {\n    key: \"jumpToState\",\n    value: function jumpToState(index) {\n      this.dispatch(new JumpToState(index));\n    }\n  }, {\n    key: \"importState\",\n    value: function importState(nextLiftedState) {\n      this.dispatch(new ImportState(nextLiftedState));\n    }\n  }, {\n    key: \"lockChanges\",\n    value: function lockChanges(status) {\n      this.dispatch(new LockChanges(status));\n    }\n  }, {\n    key: \"pauseRecording\",\n    value: function pauseRecording(status) {\n      this.dispatch(new PauseRecording(status));\n    }\n  }]);\n\n  return StoreDevtools;\n}();\n\nStoreDevtools.ɵfac = function StoreDevtools_Factory(t) {\n  return new (t || StoreDevtools)(ɵngcc0.ɵɵinject(DevtoolsDispatcher), ɵngcc0.ɵɵinject(ɵngcc1.ActionsSubject), ɵngcc0.ɵɵinject(ɵngcc1.ReducerObservable), ɵngcc0.ɵɵinject(DevtoolsExtension), ɵngcc0.ɵɵinject(ɵngcc1.ScannedActionsSubject), ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(INITIAL_STATE), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG));\n};\n\nStoreDevtools.ɵprov = ɵngcc0.ɵɵdefineInjectable({\n  token: StoreDevtools,\n  factory: StoreDevtools.ɵfac\n});\n/** @nocollapse */\n\nStoreDevtools.ctorParameters = function () {\n  return [{\n    type: DevtoolsDispatcher\n  }, {\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: DevtoolsExtension\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: ErrorHandler\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }];\n};\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreDevtools, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: DevtoolsDispatcher\n    }, {\n      type: ɵngcc1.ActionsSubject\n    }, {\n      type: ɵngcc1.ReducerObservable\n    }, {\n      type: DevtoolsExtension\n    }, {\n      type: ɵngcc1.ScannedActionsSubject\n    }, {\n      type: ɵngcc0.ErrorHandler\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [INITIAL_STATE]\n      }]\n    }, {\n      type: StoreDevtoolsConfig,\n      decorators: [{\n        type: Inject,\n        args: [STORE_DEVTOOLS_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\n\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nfunction createReduxDevtoolsExtension() {\n  var extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (typeof window === 'object' && typeof window[extensionKey] !== 'undefined') {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\n\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n\nvar StoreDevtoolsModule = /*#__PURE__*/function () {\n  function StoreDevtoolsModule() {\n    _classCallCheck(this, StoreDevtoolsModule);\n  }\n\n  _createClass(StoreDevtoolsModule, null, [{\n    key: \"instrument\",\n    value: function instrument() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        ngModule: StoreDevtoolsModule,\n        providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n          provide: INITIAL_OPTIONS,\n          useValue: options\n        }, {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent\n        }, {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension\n        }, {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig\n        }, {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable\n        }, {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher\n        }]\n      };\n    }\n  }]);\n\n  return StoreDevtoolsModule;\n}();\n\nStoreDevtoolsModule.ɵfac = function StoreDevtoolsModule_Factory(t) {\n  return new (t || StoreDevtoolsModule)();\n};\n\nStoreDevtoolsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({\n  type: StoreDevtoolsModule\n});\nStoreDevtoolsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreDevtoolsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { INITIAL_OPTIONS, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, IS_EXTENSION_OR_MONITOR_PRESENT as ɵa, createIsExtensionOrMonitorPresent as ɵb, createReduxDevtoolsExtension as ɵc, createStateObservable as ɵd, STORE_DEVTOOLS_CONFIG as ɵe, noMonitor as ɵf, createConfig as ɵg, REDUX_DEVTOOLS_EXTENSION as ɵh, DevtoolsExtension as ɵi, DevtoolsDispatcher as ɵj }; //# sourceMappingURL=ngrx-store-devtools.js.map","map":{"version":3,"sources":["/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@ngrx/store-devtools/__ivy_ngcc__/fesm2015/ngrx-store-devtools.js"],"names":["InjectionToken","Injectable","Inject","ErrorHandler","NgModule","ActionsSubject","UPDATE","INIT","ReducerObservable","ScannedActionsSubject","INITIAL_STATE","StateObservable","ReducerManagerDispatcher","EMPTY","Observable","of","merge","queueScheduler","ReplaySubject","share","filter","map","concatMap","timeout","debounceTime","catchError","take","takeUntil","switchMap","skip","observeOn","withLatestFrom","scan","ɵngcc0","ɵngcc1","StoreDevtoolsConfig","maxAge","STORE_DEVTOOLS_CONFIG","INITIAL_OPTIONS","noMonitor","DEFAULT_NAME","createConfig","_options","DEFAULT_OPTIONS","monitor","actionSanitizer","undefined","stateSanitizer","name","serialize","logOnly","features","pause","lock","persist","export","import","jump","reorder","dispatch","test","options","config","Object","assign","Error","PERFORM_ACTION","REFRESH","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","PerformAction","action","timestamp","type","Refresh","Reset","Rollback","Commit","Sweep","ToggleAction","id","SetActionsActive","start","end","active","JumpToState","index","JumpToAction","actionId","ImportState","nextLiftedState","LockChanges","status","PauseRecording","DevtoolsDispatcher","ɵfac","DevtoolsDispatcher_Factory","t","ɵDevtoolsDispatcher_BaseFactory","ɵprov","ɵɵdefineInjectable","token","factory","ɵɵgetInheritedFactory","ngDevMode","ɵsetClassMetadata","difference","first","second","item","indexOf","unliftState","liftedState","computedStates","currentStateIndex","length","state","unliftAction","actionsById","nextActionId","liftAction","Date","now","sanitizeActions","actions","keys","reduce","sanitizedActions","actionIdx","idx","Number","sanitizeAction","sanitizeStates","states","computedState","sanitizeState","error","stateIdx","shouldFilterActions","predicate","actionsSafelist","actionsBlocklist","filterLiftedState","safelist","blocklist","filteredStagedActionIds","filteredActionsById","filteredComputedStates","stagedActionIds","forEach","liftedAction","isActionFiltered","push","blockedlist","predicateMatch","safelistMatch","match","s","escapeRegExp","join","blocklistMatch","replace","ExtensionActionTypes","START","DISPATCH","STOP","ACTION","REDUX_DEVTOOLS_EXTENSION","DevtoolsExtension","devtoolsExtension","dispatcher","createActionStreams","isLocked","isPaused","currentState","sanitizedState","sanitizedAction","sendToReduxDevtools","extensionConnection","send","sanitizedLiftedState","getExtensionConfig","subscriber","connection","connect","init","subscribe","change","next","unsubscribe","changes$","createChangesObservable","pipe","start$","stop$","liftedActions$","unwrapAction","payload","actions$","actionsUntilStop$","liftedUntilStop$","eval","extensionOptions","err","console","warn","DevtoolsExtension_Factory","ɵɵinject","ctorParameters","decorators","args","INIT_ACTION","RECOMPUTE","RECOMPUTE_ACTION","computeNextEntry","reducer","errorHandler","nextState","nextError","toString","handleError","recomputeStates","minInvalidatedStateIndex","committedState","skippedActionIds","nextComputedStates","slice","lastIncludedActionId","i","previousEntry","previousState","previousError","shouldSkip","entry","liftInitialState","initialCommittedState","monitorReducer","monitorState","liftReducerWith","initialLiftedState","create","commitExcessActions","n","excess","idsToDelete","commitChanges","Infinity","concat","actionIds","Math","min","lastState","stateHasErrors","cmp","StoreDevtools","reducers$","extension","scannedActions","initialState","liftedInitialState","liftReducer","liftedAction$","asObservable","liftedReducer$","liftedStateSubject","liftedStateSubscription","reducedLiftedState","notify","unliftedAction","extensionStartSubscription","refresh","liftedState$","state$","stateSubscription","StoreDevtools_Factory","IS_EXTENSION_OR_MONITOR_PRESENT","createIsExtensionOrMonitorPresent","Boolean","createReduxDevtoolsExtension","extensionKey","window","createStateObservable","devtools","StoreDevtoolsModule","ngModule","providers","provide","useValue","deps","useFactory","useExisting","StoreDevtoolsModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","ɵa","ɵb","ɵc","ɵd","ɵe","ɵf","ɵg","ɵh","ɵi","ɵj"],"mappings":"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","sourcesContent":["import { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { EMPTY, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@ngrx/store';\nclass StoreDevtoolsConfig {\n    constructor() {\n        this.maxAge = false;\n    }\n}\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/store-devtools Options');\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/store-devtools Initial Config');\nfunction noMonitor() {\n    return null;\n}\nconst DEFAULT_NAME = 'NgRx Store DevTools';\nfunction createConfig(_options) {\n    const DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n        actionSanitizer: undefined,\n        stateSanitizer: undefined,\n        name: DEFAULT_NAME,\n        serialize: false,\n        logOnly: false,\n        // Add all features explicitly. This prevent buggy behavior for\n        // options like \"lock\" which might otherwise not show up.\n        features: {\n            pause: true,\n            lock: true,\n            persist: true,\n            export: true,\n            import: 'custom',\n            jump: true,\n            skip: true,\n            reorder: true,\n            dispatch: true,\n            test: true,\n        },\n    };\n    let options = typeof _options === 'function' ? _options() : _options;\n    const logOnly = options.logOnly\n        ? { pause: true, export: true, test: true }\n        : false;\n    const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n    const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n    }\n    return config;\n}\n\nconst PERFORM_ACTION = 'PERFORM_ACTION';\nconst REFRESH = 'REFRESH';\nconst RESET = 'RESET';\nconst ROLLBACK = 'ROLLBACK';\nconst COMMIT = 'COMMIT';\nconst SWEEP = 'SWEEP';\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nconst IMPORT_STATE = 'IMPORT_STATE';\nconst LOCK_CHANGES = 'LOCK_CHANGES';\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n    constructor(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n}\nclass Refresh {\n    constructor() {\n        this.type = REFRESH;\n    }\n}\nclass Reset {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n}\nclass Rollback {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n}\nclass Commit {\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n}\nclass Sweep {\n    constructor() {\n        this.type = SWEEP;\n    }\n}\nclass ToggleAction {\n    constructor(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n}\nclass SetActionsActive {\n    constructor(start, end, active = true) {\n        this.start = start;\n        this.end = end;\n        this.active = active;\n        this.type = SET_ACTIONS_ACTIVE;\n    }\n}\nclass JumpToState {\n    constructor(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n}\nclass JumpToAction {\n    constructor(actionId) {\n        this.actionId = actionId;\n        this.type = JUMP_TO_ACTION;\n    }\n}\nclass ImportState {\n    constructor(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n}\nclass LockChanges {\n    constructor(status) {\n        this.status = status;\n        this.type = LOCK_CHANGES;\n    }\n}\nclass PauseRecording {\n    constructor(status) {\n        this.status = status;\n        this.type = PAUSE_RECORDING;\n    }\n}\n\nclass DevtoolsDispatcher extends ActionsSubject {\n}\nDevtoolsDispatcher.ɵfac = function DevtoolsDispatcher_Factory(t) { return ɵDevtoolsDispatcher_BaseFactory(t || DevtoolsDispatcher); };\nDevtoolsDispatcher.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DevtoolsDispatcher, factory: DevtoolsDispatcher.ɵfac });\nconst ɵDevtoolsDispatcher_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(DevtoolsDispatcher);\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DevtoolsDispatcher, [{\n        type: Injectable\n    }], null, null); })();\n\nfunction difference(first, second) {\n    return first.filter((item) => second.indexOf(item) < 0);\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n    const { computedStates, currentStateIndex } = liftedState;\n    // At start up NgRx dispatches init actions,\n    // When these init actions are being filtered out by the predicate or safe/block list options\n    // we don't have a complete computed states yet.\n    // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n    if (currentStateIndex >= computedStates.length) {\n        const { state } = computedStates[computedStates.length - 1];\n        return state;\n    }\n    const { state } = computedStates[currentStateIndex];\n    return state;\n}\nfunction unliftAction(liftedState) {\n    return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action) {\n    return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n    return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n        const idx = Number(actionIdx);\n        sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n        return sanitizedActions;\n    }, {});\n}\n/**\n * Sanitizes given action with given function.\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n    return Object.assign(Object.assign({}, action), { action: actionSanitizer(action.action, actionIdx) });\n}\n/**\n * Sanitizes given states with given function.\n */\nfunction sanitizeStates(stateSanitizer, states) {\n    return states.map((computedState, idx) => ({\n        state: sanitizeState(stateSanitizer, computedState.state, idx),\n        error: computedState.error,\n    }));\n}\n/**\n * Sanitizes given state with given function.\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n    return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n */\nfunction shouldFilterActions(config) {\n    return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n    const filteredStagedActionIds = [];\n    const filteredActionsById = {};\n    const filteredComputedStates = [];\n    liftedState.stagedActionIds.forEach((id, idx) => {\n        const liftedAction = liftedState.actionsById[id];\n        if (!liftedAction)\n            return;\n        if (idx &&\n            isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n            return;\n        }\n        filteredActionsById[id] = liftedAction;\n        filteredStagedActionIds.push(id);\n        filteredComputedStates.push(liftedState.computedStates[idx]);\n    });\n    return Object.assign(Object.assign({}, liftedState), { stagedActionIds: filteredStagedActionIds, actionsById: filteredActionsById, computedStates: filteredComputedStates });\n}\n/**\n * Return true is the action should be ignored\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n    const predicateMatch = predicate && !predicate(state, action.action);\n    const safelistMatch = safelist &&\n        !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join('|'));\n    const blocklistMatch = blockedlist &&\n        action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join('|'));\n    return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\nconst ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('@ngrx/store-devtools Redux Devtools Extension');\nclass DevtoolsExtension {\n    constructor(devtoolsExtension, config, dispatcher) {\n        this.config = config;\n        this.dispatcher = dispatcher;\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    notify(action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n        if (action.type === PERFORM_ACTION) {\n            if (state.isLocked || state.isPaused) {\n                return;\n            }\n            const currentState = unliftState(state);\n            if (shouldFilterActions(this.config) &&\n                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n                return;\n            }\n            const sanitizedState = this.config.stateSanitizer\n                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)\n                : currentState;\n            const sanitizedAction = this.config.actionSanitizer\n                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)\n                : action;\n            this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n        }\n        else {\n            // Requires full state update\n            const sanitizedLiftedState = Object.assign(Object.assign({}, state), { stagedActionIds: state.stagedActionIds, actionsById: this.config.actionSanitizer\n                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n                    : state.actionsById, computedStates: this.config.stateSanitizer\n                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n                    : state.computedStates });\n            this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n        }\n    }\n    createChangesObservable() {\n        if (!this.devtoolsExtension) {\n            return EMPTY;\n        }\n        return new Observable((subscriber) => {\n            const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n            this.extensionConnection = connection;\n            connection.init();\n            connection.subscribe((change) => subscriber.next(change));\n            return connection.unsubscribe;\n        });\n    }\n    createActionStreams() {\n        // Listens to all changes\n        const changes$ = this.createChangesObservable().pipe(share());\n        // Listen for the start action\n        const start$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.START));\n        // Listen for the stop action\n        const stop$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.STOP));\n        // Listen for lifted actions\n        const liftedActions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.DISPATCH), map((change) => this.unwrapAction(change.payload)), concatMap((action) => {\n            if (action.type === IMPORT_STATE) {\n                // State imports may happen in two situations:\n                // 1. Explicitly by user\n                // 2. User activated the \"persist state accross reloads\" option\n                //    and now the state is imported during reload.\n                // Because of option 2, we need to give possible\n                // lazy loaded reducers time to instantiate.\n                // As soon as there is no UPDATE action within 1 second,\n                // it is assumed that all reducers are loaded.\n                return this.dispatcher.pipe(filter((action) => action.type === UPDATE), timeout(1000), debounceTime(1000), map(() => action), catchError(() => of(action)), take(1));\n            }\n            else {\n                return of(action);\n            }\n        }));\n        // Listen for unlifted actions\n        const actions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.ACTION), map((change) => this.unwrapAction(change.payload)));\n        const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$));\n        // Only take the action sources between the start/stop events\n        this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n        this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n    }\n    unwrapAction(action) {\n        return typeof action === 'string' ? eval(`(${action})`) : action;\n    }\n    getExtensionConfig(config) {\n        const extensionOptions = {\n            name: config.name,\n            features: config.features,\n            serialize: config.serialize,\n        };\n        if (config.maxAge !== false /* support === 0 */) {\n            extensionOptions.maxAge = config.maxAge;\n        }\n        return extensionOptions;\n    }\n    sendToReduxDevtools(send) {\n        try {\n            send();\n        }\n        catch (err) {\n            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n    }\n}\nDevtoolsExtension.ɵfac = function DevtoolsExtension_Factory(t) { return new (t || DevtoolsExtension)(ɵngcc0.ɵɵinject(REDUX_DEVTOOLS_EXTENSION), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG), ɵngcc0.ɵɵinject(DevtoolsDispatcher)); };\nDevtoolsExtension.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: DevtoolsExtension, factory: DevtoolsExtension.ɵfac });\n/** @nocollapse */\nDevtoolsExtension.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION,] }] },\n    { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] }] },\n    { type: DevtoolsDispatcher }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DevtoolsExtension, [{\n        type: Injectable\n    }], function () { return [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [REDUX_DEVTOOLS_EXTENSION]\n            }] }, { type: StoreDevtoolsConfig, decorators: [{\n                type: Inject,\n                args: [STORE_DEVTOOLS_CONFIG]\n            }] }, { type: DevtoolsDispatcher }]; }, null); })();\n\nconst INIT_ACTION = { type: INIT };\nconst RECOMPUTE = '@ngrx/store-devtools/recompute';\nconst RECOMPUTE_ACTION = { type: RECOMPUTE };\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n    if (error) {\n        return {\n            state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    let nextState = state;\n    let nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        errorHandler.handleError(err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    // If the recording is paused, recompute all states up until the pause state,\n    // else recompute all states.\n    const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n    for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n        const actionId = stagedActionIds[i];\n        const action = actionsById[actionId].action;\n        const previousEntry = nextComputedStates[i - 1];\n        const previousState = previousEntry ? previousEntry.state : committedState;\n        const previousError = previousEntry ? previousEntry.error : undefined;\n        const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        const entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n        nextComputedStates.push(entry);\n    }\n    // If the recording is paused, the last state will not be recomputed,\n    // because it's essentially not part of the state history.\n    if (isPaused) {\n        nextComputedStates.push(computedStates[computedStates.length - 1]);\n    }\n    return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n        isLocked: false,\n        isPaused: false,\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n    /**\n     * Manages how the history actions modify the history state.\n     */\n    return (reducer) => (liftedState, liftedAction) => {\n        let { monitorState, actionsById, nextActionId, stagedActionIds, skippedActionIds, committedState, currentStateIndex, computedStates, isLocked, isPaused, } = liftedState || initialLiftedState;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            let excess = n;\n            let idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (let i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter((id) => idsToDelete.indexOf(id) === -1);\n            stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n        }\n        // By default, aggressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        let minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case LOCK_CHANGES: {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case PAUSE_RECORDING: {\n                isPaused = liftedAction.status;\n                if (isPaused) {\n                    // Add a pause action to signal the devtools-user the recording is paused.\n                    // The corresponding state will be overwritten on each update to always contain\n                    // the latest state (see Actions.PERFORM_ACTION).\n                    stagedActionIds = [...stagedActionIds, nextActionId];\n                    actionsById[nextActionId] = new PerformAction({\n                        type: '@ngrx/devtools/pause',\n                    }, +Date.now());\n                    nextActionId++;\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n                    if (currentStateIndex === stagedActionIds.length - 2) {\n                        currentStateIndex++;\n                    }\n                    minInvalidatedStateIndex = Infinity;\n                }\n                else {\n                    commitChanges();\n                }\n                break;\n            }\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                commitChanges();\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { id: actionId } = liftedAction;\n                const index = skippedActionIds.indexOf(actionId);\n                if (index === -1) {\n                    skippedActionIds = [actionId, ...skippedActionIds];\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { start, end, active } = liftedAction;\n                const actionIds = [];\n                for (let i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = [...skippedActionIds, ...actionIds];\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case JUMP_TO_ACTION: {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n                const index = stagedActionIds.indexOf(liftedAction.actionId);\n                if (index !== -1)\n                    currentStateIndex = index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                    return liftedState || initialLiftedState;\n                }\n                if (isPaused ||\n                    (liftedState &&\n                        isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist))) {\n                    // If recording is paused or if the action should be ignored, overwrite the last state\n                    // (corresponds to the pause action) and keep everything else as is.\n                    // This way, the app gets the new current state while the devtools\n                    // do not record another action.\n                    const lastState = computedStates[computedStates.length - 1];\n                    computedStates = [\n                        ...computedStates.slice(0, -1),\n                        computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler),\n                    ];\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                const actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = [...stagedActionIds, actionId];\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                ({\n                    monitorState,\n                    actionsById,\n                    nextActionId,\n                    stagedActionIds,\n                    skippedActionIds,\n                    committedState,\n                    currentStateIndex,\n                    computedStates,\n                    isLocked,\n                    isPaused,\n                } = liftedAction.nextLiftedState);\n                break;\n            }\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            case UPDATE: {\n                const stateHasErrors = computedStates.filter((state) => state.error).length > 0;\n                if (stateHasErrors) {\n                    // Recompute all states\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                }\n                else {\n                    // If not paused/locked, add a new action to signal devtools-user\n                    // that there was a reducer update.\n                    if (!isPaused && !isLocked) {\n                        if (currentStateIndex === stagedActionIds.length - 1) {\n                            currentStateIndex++;\n                        }\n                        // Add a new action to only recompute state\n                        const actionId = nextActionId++;\n                        actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                        stagedActionIds = [...stagedActionIds, actionId];\n                        minInvalidatedStateIndex = stagedActionIds.length - 1;\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    }\n                    // Recompute state history with latest reducer and update action\n                    computedStates = computedStates.map((cmp) => (Object.assign(Object.assign({}, cmp), { state: reducer(cmp.state, RECOMPUTE_ACTION) })));\n                    currentStateIndex = stagedActionIds.length - 1;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                    }\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused,\n        };\n    };\n}\n\nclass StoreDevtools {\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n        const liftedInitialState = liftInitialState(initialState, config.monitor);\n        const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n        const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n        const liftedReducer$ = reducers$.pipe(map(liftReducer));\n        const liftedStateSubject = new ReplaySubject(1);\n        const liftedStateSubscription = liftedAction$\n            .pipe(withLatestFrom(liftedReducer$), scan(({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n                reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n        }, { state: liftedInitialState, action: null }))\n            .subscribe(({ state, action }) => {\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                const unliftedAction = action.action;\n                scannedActions.next(unliftedAction);\n            }\n        });\n        const extensionStartSubscription = extension.start$.subscribe(() => {\n            this.refresh();\n        });\n        const liftedState$ = liftedStateSubject.asObservable();\n        const state$ = liftedState$.pipe(map(unliftState));\n        this.extensionStartSubscription = extensionStartSubscription;\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    dispatch(action) {\n        this.dispatcher.next(action);\n    }\n    next(action) {\n        this.dispatcher.next(action);\n    }\n    error(error) { }\n    complete() { }\n    performAction(action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    refresh() {\n        this.dispatch(new Refresh());\n    }\n    reset() {\n        this.dispatch(new Reset(+Date.now()));\n    }\n    rollback() {\n        this.dispatch(new Rollback(+Date.now()));\n    }\n    commit() {\n        this.dispatch(new Commit(+Date.now()));\n    }\n    sweep() {\n        this.dispatch(new Sweep());\n    }\n    toggleAction(id) {\n        this.dispatch(new ToggleAction(id));\n    }\n    jumpToAction(actionId) {\n        this.dispatch(new JumpToAction(actionId));\n    }\n    jumpToState(index) {\n        this.dispatch(new JumpToState(index));\n    }\n    importState(nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    }\n    lockChanges(status) {\n        this.dispatch(new LockChanges(status));\n    }\n    pauseRecording(status) {\n        this.dispatch(new PauseRecording(status));\n    }\n}\nStoreDevtools.ɵfac = function StoreDevtools_Factory(t) { return new (t || StoreDevtools)(ɵngcc0.ɵɵinject(DevtoolsDispatcher), ɵngcc0.ɵɵinject(ɵngcc1.ActionsSubject), ɵngcc0.ɵɵinject(ɵngcc1.ReducerObservable), ɵngcc0.ɵɵinject(DevtoolsExtension), ɵngcc0.ɵɵinject(ɵngcc1.ScannedActionsSubject), ɵngcc0.ɵɵinject(ɵngcc0.ErrorHandler), ɵngcc0.ɵɵinject(INITIAL_STATE), ɵngcc0.ɵɵinject(STORE_DEVTOOLS_CONFIG)); };\nStoreDevtools.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StoreDevtools, factory: StoreDevtools.ɵfac });\n/** @nocollapse */\nStoreDevtools.ctorParameters = () => [\n    { type: DevtoolsDispatcher },\n    { type: ActionsSubject },\n    { type: ReducerObservable },\n    { type: DevtoolsExtension },\n    { type: ScannedActionsSubject },\n    { type: ErrorHandler },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] }] },\n    { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] }] }\n];\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreDevtools, [{\n        type: Injectable\n    }], function () { return [{ type: DevtoolsDispatcher }, { type: ɵngcc1.ActionsSubject }, { type: ɵngcc1.ReducerObservable }, { type: DevtoolsExtension }, { type: ɵngcc1.ScannedActionsSubject }, { type: ɵngcc0.ErrorHandler }, { type: undefined, decorators: [{\n                type: Inject,\n                args: [INITIAL_STATE]\n            }] }, { type: StoreDevtoolsConfig, decorators: [{\n                type: Inject,\n                args: [STORE_DEVTOOLS_CONFIG]\n            }] }]; }, null); })();\n\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('@ngrx/store-devtools Is Devtools Extension or Monitor Present');\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n    const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof window[extensionKey] !== 'undefined') {\n        return window[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\nclass StoreDevtoolsModule {\n    static instrument(options = {}) {\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    }\n}\nStoreDevtoolsModule.ɵfac = function StoreDevtoolsModule_Factory(t) { return new (t || StoreDevtoolsModule)(); };\nStoreDevtoolsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StoreDevtoolsModule });\nStoreDevtoolsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({});\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StoreDevtoolsModule, [{\n        type: NgModule,\n        args: [{}]\n    }], null, null); })();\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, IS_EXTENSION_OR_MONITOR_PRESENT as ɵa, createIsExtensionOrMonitorPresent as ɵb, createReduxDevtoolsExtension as ɵc, createStateObservable as ɵd, STORE_DEVTOOLS_CONFIG as ɵe, noMonitor as ɵf, createConfig as ɵg, REDUX_DEVTOOLS_EXTENSION as ɵh, DevtoolsExtension as ɵi, DevtoolsDispatcher as ɵj };\n\n//# sourceMappingURL=ngrx-store-devtools.js.map"]},"metadata":{},"sourceType":"module"}