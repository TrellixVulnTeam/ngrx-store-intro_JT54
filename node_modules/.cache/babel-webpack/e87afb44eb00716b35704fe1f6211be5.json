{"ast":null,"code":"import _defineProperty from \"/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport * as deepmerge from 'deepmerge';\nvar INIT_ACTION = '@ngrx/store/init';\nvar UPDATE_ACTION = '@ngrx/store/update-reducers';\nvar detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/; // correctly parse dates from local storage\n\nvar dateReviver = function dateReviver(_key, value) {\n  if (typeof value === 'string' && detectDate.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n};\n\nvar dummyReviver = function dummyReviver(_key, value) {\n  return value;\n};\n\nvar ɵ0 = dummyReviver;\n\nvar checkIsBrowserEnv = function checkIsBrowserEnv() {\n  return typeof window !== 'undefined';\n};\n\nvar ɵ1 = checkIsBrowserEnv;\n\nvar validateStateKeys = function validateStateKeys(keys) {\n  return keys.map(function (key) {\n    var attr = key;\n\n    if (typeof key === 'object') {\n      attr = Object.keys(key)[0];\n    }\n\n    if (typeof attr !== 'string') {\n      throw new TypeError(\"localStorageSync Unknown Parameter Type: \" + \"Expected type of string, got \".concat(typeof attr));\n    }\n\n    return key;\n  });\n};\n\nvar ɵ2 = validateStateKeys;\n\nvar rehydrateApplicationState = function rehydrateApplicationState(keys, storage, storageKeySerializer, restoreDates) {\n  return keys.reduce(function (acc, curr) {\n    var key = curr;\n    var reviver = restoreDates ? dateReviver : dummyReviver;\n    var deserialize;\n    var decrypt;\n\n    if (typeof key === 'object') {\n      key = Object.keys(key)[0]; // use the custom reviver function\n\n      if (typeof curr[key] === 'function') {\n        reviver = curr[key];\n      } else {\n        // use custom reviver function if available\n        if (curr[key].reviver) {\n          reviver = curr[key].reviver;\n        } // use custom serialize function if available\n\n\n        if (curr[key].deserialize) {\n          deserialize = curr[key].deserialize;\n        }\n      } // Ensure that encrypt and decrypt functions are both present\n\n\n      if (curr[key].encrypt && curr[key].decrypt) {\n        if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n          decrypt = curr[key].decrypt;\n        } else {\n          console.error(\"Either encrypt or decrypt is not a function on '\".concat(curr[key], \"' key object.\"));\n        }\n      } else if (curr[key].encrypt || curr[key].decrypt) {\n        // Let know that one of the encryption functions is not provided\n        console.error(\"Either encrypt or decrypt function is not present on '\".concat(curr[key], \"' key object.\"));\n      }\n    }\n\n    if (storage !== undefined) {\n      var stateSlice = storage.getItem(storageKeySerializer(key));\n\n      if (stateSlice) {\n        // Use provided decrypt function\n        if (decrypt) {\n          stateSlice = decrypt(stateSlice);\n        }\n\n        var isObjectRegex = new RegExp('{|\\\\[');\n        var raw = stateSlice;\n\n        if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n          raw = JSON.parse(stateSlice, reviver);\n        }\n\n        return Object.assign({}, acc, _defineProperty({}, key, deserialize ? deserialize(raw) : raw));\n      }\n    }\n\n    return acc;\n  }, {});\n}; // Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\n\n\nfunction createStateSlice(existingSlice, filter) {\n  return filter.reduce(function (memo, attr) {\n    if (typeof attr === 'string' || typeof attr === 'number') {\n      var value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];\n\n      if (value !== undefined) {\n        memo[attr] = value;\n      }\n    } else {\n      for (var key in attr) {\n        if (Object.prototype.hasOwnProperty.call(attr, key)) {\n          var element = attr[key];\n          memo[key] = createStateSlice(existingSlice[key], element);\n        }\n      }\n    }\n\n    return memo;\n  }, {});\n}\n\nvar syncStateUpdate = function syncStateUpdate(state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) {\n  if (syncCondition) {\n    try {\n      if (syncCondition(state) !== true) {\n        return;\n      }\n    } catch (e) {\n      // Treat TypeError as do not sync\n      if (e instanceof TypeError) {\n        return;\n      }\n\n      throw e;\n    }\n  }\n\n  keys.forEach(function (key) {\n    var stateSlice = state[key];\n    var replacer;\n    var space;\n    var encrypt;\n\n    if (typeof key === 'object') {\n      var name = Object.keys(key)[0];\n      stateSlice = state[name];\n\n      if (typeof stateSlice !== 'undefined' && key[name]) {\n        // use serialize function if specified.\n        if (key[name].serialize) {\n          stateSlice = key[name].serialize(stateSlice);\n        } else {\n          // if serialize function is not specified filter on fields if an array has been provided.\n          var filter;\n\n          if (key[name].reduce) {\n            filter = key[name];\n          } else if (key[name].filter) {\n            filter = key[name].filter;\n          }\n\n          if (filter) {\n            stateSlice = createStateSlice(stateSlice, filter);\n          } // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n\n\n          if (key[name].encrypt && key[name].decrypt) {\n            if (typeof key[name].encrypt === 'function') {\n              encrypt = key[name].encrypt;\n            }\n          } else if (key[name].encrypt || key[name].decrypt) {\n            // If one of those is not present, then let know that one is missing\n            console.error(\"Either encrypt or decrypt function is not present on '\".concat(key[name], \"' key object.\"));\n          }\n        }\n        /*\n        Replacer and space arguments to pass to JSON.stringify.\n        If these fields don't exist, undefined will be passed.\n        */\n\n\n        replacer = key[name].replacer;\n        space = key[name].space;\n      }\n\n      key = name;\n    }\n\n    if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n      try {\n        if (encrypt) {\n          // ensure that a string message is passed\n          stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n        }\n\n        storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n      } catch (e) {\n        console.warn('Unable to save state to localStorage:', e);\n      }\n    } else if (typeof stateSlice === 'undefined' && removeOnUndefined) {\n      try {\n        storage.removeItem(storageKeySerializer(key));\n      } catch (e) {\n        console.warn(\"Exception on removing/cleaning undefined '\".concat(key, \"' state\"), e);\n      }\n    }\n  });\n}; // Default merge strategy is a full deep merge.\n\n\nvar defaultMergeReducer = function defaultMergeReducer(state, rehydratedState, action) {\n  if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n    var overwriteMerge = function overwriteMerge(destinationArray, sourceArray, options) {\n      return sourceArray;\n    };\n\n    var options = {\n      arrayMerge: overwriteMerge\n    };\n    state = deepmerge(state, rehydratedState, options);\n  }\n\n  return state;\n};\n\nvar localStorageSync = function localStorageSync(config) {\n  return function (reducer) {\n    if (config.storage === undefined && !config.checkStorageAvailability || config.checkStorageAvailability && checkIsBrowserEnv()) {\n      config.storage = localStorage || window.localStorage;\n    }\n\n    if (config.storageKeySerializer === undefined) {\n      config.storageKeySerializer = function (key) {\n        return key;\n      };\n    }\n\n    if (config.restoreDates === undefined) {\n      config.restoreDates = true;\n    } // Use default merge reducer.\n\n\n    var mergeReducer = config.mergeReducer;\n\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n      mergeReducer = defaultMergeReducer;\n    }\n\n    var stateKeys = validateStateKeys(config.keys);\n    var rehydratedState = config.rehydrate ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates) : undefined;\n    return function (state, action) {\n      var nextState; // If state arrives undefined, we need to let it through the supplied reducer\n      // in order to get a complete state as defined by user\n\n      if (action.type === INIT_ACTION && !state) {\n        nextState = reducer(state, action);\n      } else {\n        nextState = Object.assign({}, state);\n      } // Merge the store state with the rehydrated state using\n      // either a user-defined reducer or the default.\n\n\n      nextState = mergeReducer(nextState, rehydratedState, action);\n      nextState = reducer(nextState, action);\n\n      if (action.type !== INIT_ACTION) {\n        syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n      }\n\n      return nextState;\n    };\n  };\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate, ɵ0, ɵ1, ɵ2 }; //# sourceMappingURL=ngrx-store-localstorage.js.map","map":{"version":3,"sources":["/Users/volodymyrmaliarov/Projects/ngRxIntro/ngrx-store-intro/node_modules/ngrx-store-localstorage/__ivy_ngcc__/fesm2015/ngrx-store-localstorage.js"],"names":["deepmerge","INIT_ACTION","UPDATE_ACTION","detectDate","dateReviver","_key","value","test","Date","dummyReviver","ɵ0","checkIsBrowserEnv","window","ɵ1","validateStateKeys","keys","map","key","attr","Object","TypeError","ɵ2","rehydrateApplicationState","storage","storageKeySerializer","restoreDates","reduce","acc","curr","reviver","deserialize","decrypt","encrypt","console","error","undefined","stateSlice","getItem","isObjectRegex","RegExp","raw","charAt","JSON","parse","assign","createStateSlice","existingSlice","filter","memo","prototype","hasOwnProperty","call","element","syncStateUpdate","state","removeOnUndefined","syncCondition","e","forEach","replacer","space","name","serialize","stringify","setItem","warn","removeItem","defaultMergeReducer","rehydratedState","action","type","overwriteMerge","destinationArray","sourceArray","options","arrayMerge","localStorageSync","config","reducer","checkStorageAvailability","localStorage","mergeReducer","stateKeys","rehydrate","nextState"],"mappings":"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","sourcesContent":["import * as deepmerge from 'deepmerge';\n\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n// correctly parse dates from local storage\nconst dateReviver = (_key, value) => {\n    if (typeof value === 'string' && detectDate.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\nconst dummyReviver = (_key, value) => value;\nconst ɵ0 = dummyReviver;\nconst checkIsBrowserEnv = () => {\n    return typeof window !== 'undefined';\n};\nconst ɵ1 = checkIsBrowserEnv;\nconst validateStateKeys = (keys) => {\n    return keys.map((key) => {\n        let attr = key;\n        if (typeof key === 'object') {\n            attr = Object.keys(key)[0];\n        }\n        if (typeof attr !== 'string') {\n            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);\n        }\n        return key;\n    });\n};\nconst ɵ2 = validateStateKeys;\nconst rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {\n    return keys.reduce((acc, curr) => {\n        let key = curr;\n        let reviver = restoreDates ? dateReviver : dummyReviver;\n        let deserialize;\n        let decrypt;\n        if (typeof key === 'object') {\n            key = Object.keys(key)[0];\n            // use the custom reviver function\n            if (typeof curr[key] === 'function') {\n                reviver = curr[key];\n            }\n            else {\n                // use custom reviver function if available\n                if (curr[key].reviver) {\n                    reviver = curr[key].reviver;\n                }\n                // use custom serialize function if available\n                if (curr[key].deserialize) {\n                    deserialize = curr[key].deserialize;\n                }\n            }\n            // Ensure that encrypt and decrypt functions are both present\n            if (curr[key].encrypt && curr[key].decrypt) {\n                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n                    decrypt = curr[key].decrypt;\n                }\n                else {\n                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n                }\n            }\n            else if (curr[key].encrypt || curr[key].decrypt) {\n                // Let know that one of the encryption functions is not provided\n                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n            }\n        }\n        if (storage !== undefined) {\n            let stateSlice = storage.getItem(storageKeySerializer(key));\n            if (stateSlice) {\n                // Use provided decrypt function\n                if (decrypt) {\n                    stateSlice = decrypt(stateSlice);\n                }\n                const isObjectRegex = new RegExp('{|\\\\[');\n                let raw = stateSlice;\n                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n                    raw = JSON.parse(stateSlice, reviver);\n                }\n                return Object.assign({}, acc, {\n                    [key]: deserialize ? deserialize(raw) : raw,\n                });\n            }\n        }\n        return acc;\n    }, {});\n};\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice, filter) {\n    return filter.reduce((memo, attr) => {\n        if (typeof attr === 'string' || typeof attr === 'number') {\n            const value = existingSlice === null || existingSlice === void 0 ? void 0 : existingSlice[attr];\n            if (value !== undefined) {\n                memo[attr] = value;\n            }\n        }\n        else {\n            for (const key in attr) {\n                if (Object.prototype.hasOwnProperty.call(attr, key)) {\n                    const element = attr[key];\n                    memo[key] = createStateSlice(existingSlice[key], element);\n                }\n            }\n        }\n        return memo;\n    }, {});\n}\nconst syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {\n    if (syncCondition) {\n        try {\n            if (syncCondition(state) !== true) {\n                return;\n            }\n        }\n        catch (e) {\n            // Treat TypeError as do not sync\n            if (e instanceof TypeError) {\n                return;\n            }\n            throw e;\n        }\n    }\n    keys.forEach((key) => {\n        let stateSlice = state[key];\n        let replacer;\n        let space;\n        let encrypt;\n        if (typeof key === 'object') {\n            let name = Object.keys(key)[0];\n            stateSlice = state[name];\n            if (typeof stateSlice !== 'undefined' && key[name]) {\n                // use serialize function if specified.\n                if (key[name].serialize) {\n                    stateSlice = key[name].serialize(stateSlice);\n                }\n                else {\n                    // if serialize function is not specified filter on fields if an array has been provided.\n                    let filter;\n                    if (key[name].reduce) {\n                        filter = key[name];\n                    }\n                    else if (key[name].filter) {\n                        filter = key[name].filter;\n                    }\n                    if (filter) {\n                        stateSlice = createStateSlice(stateSlice, filter);\n                    }\n                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n                    if (key[name].encrypt && key[name].decrypt) {\n                        if (typeof key[name].encrypt === 'function') {\n                            encrypt = key[name].encrypt;\n                        }\n                    }\n                    else if (key[name].encrypt || key[name].decrypt) {\n                        // If one of those is not present, then let know that one is missing\n                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);\n                    }\n                }\n                /*\n          Replacer and space arguments to pass to JSON.stringify.\n          If these fields don't exist, undefined will be passed.\n        */\n                replacer = key[name].replacer;\n                space = key[name].space;\n            }\n            key = name;\n        }\n        if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n            try {\n                if (encrypt) {\n                    // ensure that a string message is passed\n                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n                }\n                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));\n            }\n            catch (e) {\n                console.warn('Unable to save state to localStorage:', e);\n            }\n        }\n        else if (typeof stateSlice === 'undefined' && removeOnUndefined) {\n            try {\n                storage.removeItem(storageKeySerializer(key));\n            }\n            catch (e) {\n                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n            }\n        }\n    });\n};\n// Default merge strategy is a full deep merge.\nconst defaultMergeReducer = (state, rehydratedState, action) => {\n    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;\n        const options = {\n            arrayMerge: overwriteMerge,\n        };\n        state = deepmerge(state, rehydratedState, options);\n    }\n    return state;\n};\nconst localStorageSync = (config) => (reducer) => {\n    if ((config.storage === undefined && !config.checkStorageAvailability) ||\n        (config.checkStorageAvailability && checkIsBrowserEnv())) {\n        config.storage = localStorage || window.localStorage;\n    }\n    if (config.storageKeySerializer === undefined) {\n        config.storageKeySerializer = (key) => key;\n    }\n    if (config.restoreDates === undefined) {\n        config.restoreDates = true;\n    }\n    // Use default merge reducer.\n    let mergeReducer = config.mergeReducer;\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n        mergeReducer = defaultMergeReducer;\n    }\n    const stateKeys = validateStateKeys(config.keys);\n    const rehydratedState = config.rehydrate\n        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)\n        : undefined;\n    return function (state, action) {\n        let nextState;\n        // If state arrives undefined, we need to let it through the supplied reducer\n        // in order to get a complete state as defined by user\n        if (action.type === INIT_ACTION && !state) {\n            nextState = reducer(state, action);\n        }\n        else {\n            nextState = Object.assign({}, state);\n        }\n        // Merge the store state with the rehydrated state using\n        // either a user-defined reducer or the default.\n        nextState = mergeReducer(nextState, rehydratedState, action);\n        nextState = reducer(nextState, action);\n        if (action.type !== INIT_ACTION) {\n            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);\n        }\n        return nextState;\n    };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { dateReviver, defaultMergeReducer, localStorageSync, rehydrateApplicationState, syncStateUpdate, ɵ0, ɵ1, ɵ2 };\n\n//# sourceMappingURL=ngrx-store-localstorage.js.map"]},"metadata":{},"sourceType":"module"}